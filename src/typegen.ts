import type { MockServerConfig, JsonValue } from './types.js';

// ── Faker → TS type mapping ──────────────────────

const FAKER_TYPES: Record<string, string> = {
  'faker.id':        'string',
  'faker.name':      'string',
  'faker.firstName': 'string',
  'faker.lastName':  'string',
  'faker.email':     'string',
  'faker.phone':     'string',
  'faker.number':    'number',
  'faker.boolean':   'boolean',
  'faker.date':      'string',
  'faker.timestamp': 'number',
  'faker.company':   'string',
  'faker.title':     'string',
  'faker.url':       'string',
  'faker.avatar':    'string',
  'faker.color':     'string',
  'faker.ip':        'string',
  'faker.slug':      'string',
  'faker.lorem':     'string',
  'faker.paragraph': 'string',
};

// ── Public API ────────────────────────────────────

export function generateTypes(config: MockServerConfig): string {
  const lines: string[] = [];
  const generatedNames = new Set<string>();

  lines.push('// Auto-generated by quickmock');
  lines.push(`// Server: ${config.name}`);
  lines.push(`// Generated: ${new Date().toISOString()}`);
  lines.push('');

  // Resource interfaces
  for (const [name, cfg] of Object.entries(config.resources ?? {})) {
    const interfaceName = toInterfaceName(name, generatedNames);
    const typeLines = inferInterface(interfaceName, cfg.seed, generatedNames);
    lines.push(...typeLines);
    lines.push('');
  }

  // Route response interfaces
  for (const route of config.routes ?? []) {
    if (route.response === undefined || route.response === null) continue;
    const routeName = routeToInterfaceName(route.method ?? 'GET', route.path, generatedNames);
    const typeLines = inferInterface(routeName, route.response, generatedNames);
    lines.push(...typeLines);
    lines.push('');
  }

  // List response generic
  if (Object.keys(config.resources ?? {}).length > 0) {
    lines.push('/** Generic list response with pagination */');
    lines.push('export interface ListResponse<T> {');
    lines.push('  items: T[];');
    lines.push('  total: number;');
    lines.push('  limit?: number;');
    lines.push('  offset?: number;');
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}

// ── Type inference ────────────────────────────────

function inferInterface(
  name: string,
  value: JsonValue,
  generatedNames: Set<string>,
): string[] {
  const lines: string[] = [];

  if (value && typeof value === 'object' && !Array.isArray(value)) {
    lines.push(`export interface ${name} {`);
    for (const [key, val] of Object.entries(value)) {
      const propName = isValidIdentifier(key) ? key : `'${key}'`;
      const typeStr = inferTypeFromValue(key, val, name, generatedNames, lines);
      lines.push(`  ${propName}: ${typeStr};`);
    }
    lines.push('}');
  } else if (Array.isArray(value)) {
    // Top-level array: create a type alias
    if (value.length > 0) {
      const itemType = inferTypeFromValue('item', value[0], name, generatedNames, lines);
      lines.push(`export type ${name} = ${itemType}[];`);
    } else {
      lines.push(`export type ${name} = unknown[];`);
    }
  } else {
    // Primitive response
    const tsType = inferPrimitiveType(value);
    lines.push(`export type ${name} = ${tsType};`);
  }

  return lines;
}

function inferTypeFromValue(
  key: string,
  value: JsonValue,
  parentName: string,
  generatedNames: Set<string>,
  extraLines: string[],
): string {
  // Faker template string
  if (typeof value === 'string') {
    const m = value.match(/^\{\{(.+?)\}\}$/);
    if (m) return FAKER_TYPES[m[1].trim()] ?? 'string';
    return 'string';
  }

  if (typeof value === 'number') return 'number';
  if (typeof value === 'boolean') return 'boolean';
  if (value === null) return 'null';

  // Array
  if (Array.isArray(value)) {
    if (value.length === 0) return 'unknown[]';
    const first = value[0];
    if (first && typeof first === 'object' && !Array.isArray(first)) {
      const nestedName = toInterfaceName(key, generatedNames);
      const nested = inferInterface(nestedName, first, generatedNames);
      // Insert nested interface before the parent (they'll be reordered at top level)
      extraLines.unshift(...nested, '');
      return `${nestedName}[]`;
    }
    return `${inferPrimitiveType(first)}[]`;
  }

  // Nested object
  if (typeof value === 'object') {
    const nestedName = toInterfaceName(key, generatedNames);
    const nested = inferInterface(nestedName, value, generatedNames);
    extraLines.unshift(...nested, '');
    return nestedName;
  }

  return 'unknown';
}

function inferPrimitiveType(value: JsonValue): string {
  if (typeof value === 'string') {
    const m = value.match(/^\{\{(.+?)\}\}$/);
    if (m) return FAKER_TYPES[m[1].trim()] ?? 'string';
    return 'string';
  }
  if (typeof value === 'number') return 'number';
  if (typeof value === 'boolean') return 'boolean';
  if (value === null) return 'null';
  return 'unknown';
}

// ── Naming helpers ────────────────────────────────

function toInterfaceName(input: string, used: Set<string>): string {
  // Convert kebab/snake to PascalCase, singularize simple plurals
  let name = input
    .replace(/[-_\s]+(.)/g, (_, c) => c.toUpperCase())
    .replace(/^(.)/, (_, c) => c.toUpperCase());

  // Simple singularize: remove trailing 's' if the result is still >= 3 chars
  if (name.endsWith('s') && name.length > 3 && !name.endsWith('ss')) {
    name = name.slice(0, -1);
  }

  // Ensure uniqueness
  let candidate = name;
  let i = 2;
  while (used.has(candidate)) {
    candidate = `${name}${i++}`;
  }
  used.add(candidate);
  return candidate;
}

function routeToInterfaceName(method: string, path: string, used: Set<string>): string {
  // /auth/me -> AuthMeResponse, /api/health -> ApiHealthResponse
  const segments = path.split('/').filter(s => s && !s.startsWith(':'));
  const name = segments.map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('') + 'Response';
  return toInterfaceName(name.replace(/[^a-zA-Z0-9]/g, ''), used);
}

function isValidIdentifier(s: string): boolean {
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(s);
}
